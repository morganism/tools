#!/usr/bin/env ruby
# frozen_string_literal: true
#
# mandarin_install.rb — self-contained installer for mandarin.rb v2.0.0
#
# Generated by doc_generator.rb. The MANIFEST constant below is the
# source of truth — also available as mandarin.install.json.
# To regenerate: ruby doc_generator.rb mandarin.rb

require 'fileutils'
require 'json'
require 'optparse'

MANIFEST = JSON.parse(<<~'JSON')
{"binary":{"source":"mandarin.rb","target":"mandarin","destination":"/usr/local/bin","chmod":"0755"},"man_pages":[{"source":"mandarin.1","section":"1","destination":"/usr/local/share/man/man1"}],"dependencies":{"ruby_version":"3.0","gems":[],"system_bins":[{"bin":"install","package":"coreutils","optional":false},{"bin":"mandb","package":"man-db","optional":true},{"bin":"sudo","package":"sudo","optional":true}]},"environment":[],"config_dirs":[],"config_files":[],"post_install_notes":["Ensure /usr/local/bin is in your PATH.","Generate manifest files for your tools using doc_generator.rb before running mandarin.","Use --dry-run on first use to preview what mandarin will do before committing changes.","When installing to system directories (/usr/local/bin), use --sudo."],"uninstall_notes":["Run: mandarin --manifest mandarin.install.json --uninstall (or --uninstall --dry-run to preview).","Remove /usr/local/bin/mandarin manually if the self-uninstall path is not available.","Remove /usr/local/share/man/man1/mandarin.1 if it was installed.","Any *.install.json manifest files in your project directories are not removed automatically."],"name":"mandarin","version":"2.0.0","author":"morgan"}
JSON

VERSION     = "2.0.0"
SCRIPT_NAME = File.basename($PROGRAM_NAME)

# ANSI colour helpers — degrade gracefully if stdout is not a tty
COLOUR = $stdout.tty?
def ansi(code, str) = COLOUR ? "\e[#{code}m#{str}\e[0m" : str
def ok(msg)    = puts "  #{ansi('32',  '✔')}  #{msg}"
def warn_(msg) = puts "  #{ansi('33',  '⚠')}  #{msg}"   # warn_ avoids clobbering Kernel#warn
def err(msg)   = puts "  #{ansi('31',  '✘')}  #{msg}"
def info(msg)  = puts "  #{ansi('34',  '→')}  #{msg}"
def dry(msg)   = puts "  #{ansi('36', '[DRY]')}  #{msg}" # cyan — would-do actions

options = {
  action:   nil,
  prefix:   MANIFEST.dig('binary', 'destination')&.then { |d| File.dirname(d) } || '/usr/local',
  sudo:     false,
  force:    false,
  dry_run:  false,
  verbose:  false
}

parser = OptionParser.new do |o|
  o.banner = "Usage: #{SCRIPT_NAME} <action> [options]"
  o.separator ''
  o.separator 'Actions (required, pick one):'
  o.on('--install',   'Install binary, man page, verify deps')  { options[:action] = :install   }
  o.on('--uninstall', 'Remove all installed files')              { options[:action] = :uninstall }
  o.on('--check',     'Verify dependencies only (no file ops)')  { options[:action] = :check     }
  o.separator ''
  o.separator 'Options:'
  o.on('-n', '--dry-run',
       'Simulate --install or --uninstall: print every action',
       'that WOULD be taken without changing anything on disk.') { options[:dry_run] = true }
  o.on('-p', '--prefix DIR',
       "Install prefix (default: #{options[:prefix]})") { |d| options[:prefix] = d }
  o.on('--sudo',    'Prefix shell commands with sudo')  { options[:sudo]    = true }
  o.on('--force',   'Overwrite existing files')         { options[:force]   = true }
  o.on('-v', '--verbose', 'Show each command as run')   { options[:verbose] = true }
  o.on('-V', '--version') { puts "#{SCRIPT_NAME} v#{VERSION}"; exit }
  o.on('-h', '--help')    { puts o; exit }
  o.separator ''
  o.separator 'Examples:'
  o.separator "  #{SCRIPT_NAME} --install --dry-run          # simulate install, touch nothing"
  o.separator "  #{SCRIPT_NAME} --install --prefix ~/.local  # install to home prefix"
  o.separator "  #{SCRIPT_NAME} --install --sudo             # install to system prefix"
  o.separator "  #{SCRIPT_NAME} --uninstall --dry-run        # see what uninstall would remove"
  o.separator "  #{SCRIPT_NAME} --check                      # dep check only"
end

parser.parse!

if options[:action].nil?
  warn "#{SCRIPT_NAME}: error: specify --install, --uninstall, or --check"
  abort parser.banner
end

if options[:dry_run] && options[:action] == :check
  warn "#{SCRIPT_NAME}: --dry-run has no effect with --check (--check is already non-destructive)"
  options[:dry_run] = false
end

# ---------------------------------------------------------------------------
# Core helpers
# ---------------------------------------------------------------------------

def expand_path(path, prefix)
  path.to_s.sub('~', Dir.home).sub('{prefix}', prefix)
end

def bin_available?(name)
  system("which #{name} >/dev/null 2>&1")
end

# act() is the single gate for all side-effecting operations.
#
# In normal mode:  runs the block, prints label on verbose.
# In dry-run mode: prints what would happen — block is NEVER called.
#
# Usage:
#   act("install /foo/bar", dry_run: opts[:dry_run], verbose: opts[:verbose]) do
#     FileUtils.cp(src, dst)
#   end
def act(description, dry_run:, verbose:, sudo_prefix: nil)
  prefix_str = sudo_prefix ? "sudo " : ""
  if dry_run
    dry "#{prefix_str}#{description}"
  else
    puts "    #{prefix_str}#{description}" if verbose
    yield
  end
end

# Thin wrapper for shell commands routed through act()
def sh(cmd, opts)
  act(cmd, dry_run: opts[:dry_run], verbose: opts[:verbose],
      sudo_prefix: opts[:sudo] ? true : nil) do
    full = opts[:sudo] ? "sudo #{cmd}" : cmd
    system(full) || abort("Command failed: #{full}")
  end
end

# FileUtils wrappers — all routed through act() so dry-run is uniform
def fs_mkdir_p(dir, opts)
  act("mkdir -p #{dir}", dry_run: opts[:dry_run], verbose: opts[:verbose],
      sudo_prefix: opts[:sudo] ? true : nil) do
    if opts[:sudo]
      system("sudo mkdir -p #{dir}") || abort("mkdir failed: #{dir}")
    else
      FileUtils.mkdir_p(dir)
    end
  end
end

def fs_install(src, dst, chmod, opts)
  act("install -m #{chmod} #{src} #{dst}",
      dry_run: opts[:dry_run], verbose: opts[:verbose],
      sudo_prefix: opts[:sudo] ? true : nil) do
    sh_cmd = "install -m #{chmod} #{src} #{dst}"
    full   = opts[:sudo] ? "sudo #{sh_cmd}" : sh_cmd
    system(full) || abort("install failed: #{src} → #{dst}")
  end
end

def fs_cp(src, dst, mode, opts)
  act("cp #{src} #{dst}  (mode #{mode})",
      dry_run: opts[:dry_run], verbose: opts[:verbose]) do
    FileUtils.mkdir_p(File.dirname(dst))
    FileUtils.cp(src, dst)
    FileUtils.chmod(mode.to_i(8), dst)
  end
end

def fs_rm(path, opts)
  act("rm #{path}", dry_run: opts[:dry_run], verbose: opts[:verbose],
      sudo_prefix: opts[:sudo] ? true : nil) do
    if opts[:sudo]
      system("sudo rm #{path}") || abort("rm failed: #{path}")
    else
      FileUtils.rm(path)
    end
  end
end

def fs_chmod(path, mode, opts)
  act("chmod #{mode} #{path}", dry_run: opts[:dry_run], verbose: opts[:verbose]) do
    FileUtils.chmod(mode.to_i(8), path)
  end
end

# ---------------------------------------------------------------------------
# Dependency check — used by --check and --install (also --install --dry-run)
# Deps are ALWAYS checked for real, even in dry-run — that's the whole point.
# Returns array of blocking issue strings.
# ---------------------------------------------------------------------------

def check_deps(manifest)
  dep    = manifest['dependencies'] || {}
  issues = []

  min = dep['ruby_version'] || '2.7'
  if Gem::Version.new(RUBY_VERSION) < Gem::Version.new(min)
    err "Ruby #{min}+ required, running #{RUBY_VERSION}"
    issues << :ruby_version
  else
    ok "Ruby #{RUBY_VERSION} >= #{min}"
  end

  Array(dep['gems']).each do |g|
    begin
      gem g['name'], g['version'] || '>= 0'
      ok "gem #{g['name']} #{g['version']}"
    rescue Gem::LoadError
      label = "gem #{g['name']} #{g['version']}"
      if g['optional']
        warn_ "#{label} not installed (optional)"
      else
        err   "#{label} missing — run: gem install #{g['name']}"
        issues << "gem:#{g['name']}"
      end
    end
  end

  Array(dep['system_bins']).each do |b|
    if bin_available?(b['bin'])
      ok "binary #{b['bin']} found"
    elsif b['optional']
      warn_ "binary #{b['bin']} not found (optional) — apt/brew install #{b['package']}"
    else
      err   "binary #{b['bin']} not found — install: #{b['package']}"
      issues << "bin:#{b['bin']}"
    end
  end

  Array(manifest['environment']).each do |e|
    val = ENV[e['var']]
    if val && !val.strip.empty?
      ok "env #{e['var']} set"
    elsif e['required']
      err "env #{e['var']} not set — #{e['description']}"
      warn_("  Hint: #{e['suggest_export']}  → add to ~/.bashrc") if e['suggest_export']
      issues << "env:#{e['var']}"
    else
      warn_ "env #{e['var']} not set (optional) — #{e['description']}"
    end
  end

  issues
end

# ---------------------------------------------------------------------------
# --install  (also handles --install --dry-run)
# ---------------------------------------------------------------------------

def do_install(manifest, opts)
  prefix  = opts[:prefix]
  dry_run = opts[:dry_run]

  banner = dry_run ? "DRY-RUN — no files will be written" : "Installing #{manifest['name']} v#{manifest['version']}"
  puts "\n=== #{banner} ===\n"

  puts "\n--- Dependency check (always live, even in dry-run) ---"
  issues = check_deps(manifest)

  unless issues.empty?
    err "Blocking issues — fix before installing:"
    issues.each { |i| err "  #{i}" }
    # In dry-run we warn but continue so the full plan is visible
    exit 1 unless dry_run
    warn_ "Continuing dry-run despite issues so you can see the full plan..."
  end

  # Binary
  bin     = manifest['binary'] || {}
  src     = bin['source'].to_s
  dst_dir = expand_path(bin['destination'] || "#{prefix}/bin", prefix)
  dst     = File.join(dst_dir, bin['target'] || File.basename(src, '.*'))
  chmod   = bin['chmod'] || '0755'

  puts "\n--- Binary ---"
  unless File.exist?(src)
    # In dry-run we note the missing source but continue showing the plan
    if dry_run
      warn_ "Source not found: #{src} — in a real install this would abort here"
    else
      abort "  #{ansi('31','✘')}  Source not found: #{src}"
    end
  end

  if !dry_run && File.exist?(dst) && !opts[:force]
    err "Already installed: #{dst}  (use --force to overwrite)"
    exit 1
  end

  info "Would install: #{src} → #{dst}  (chmod #{chmod})" if dry_run
  fs_mkdir_p(dst_dir, opts)
  fs_install(src, dst, chmod, opts)
  ok "#{src} → #{dst}" unless dry_run

  # Man pages
  Array(manifest['man_pages']).each do |mp|
    msrc = mp['source'].to_s
    mdir = expand_path(mp['destination'] || "#{prefix}/share/man/man#{mp['section']}", prefix)
    mdst = File.join(mdir, File.basename(msrc))

    puts "\n--- Man page (section #{mp['section']}) ---"

    unless File.exist?(msrc)
      msg = "#{msrc} not found — run doc_generator.rb first"
      dry_run ? warn_("Would skip: #{msg}") : warn_(msg)
      next
    end

    info "Would install: #{msrc} → #{mdst}" if dry_run
    fs_mkdir_p(mdir, opts)
    fs_install(msrc, mdst, '0644', opts)
    ok "#{msrc} → #{mdst}" unless dry_run

    unless dry_run
      %w[mandb makewhatis].each do |cmd|
        next unless bin_available?(cmd)
        sh("#{cmd} -q 2>/dev/null || true", opts)
        break
      end
    else
      dry "mandb / makewhatis  (man index refresh)"
    end
  end

  # Config dirs
  Array(manifest['config_dirs']).each do |cd|
    dir  = expand_path(cd['path'], prefix)
    mode = cd['mode'] || '0700'
    puts "\n--- Config dir ---"
    info "Would create: #{dir}  (mode #{mode})" if dry_run
    fs_mkdir_p(dir, opts)
    fs_chmod(dir, mode, opts)
    ok "#{dir}  (mode #{mode})" unless dry_run
  end

  # Config files
  Array(manifest['config_files']).each do |cf|
    csrc = cf['source'].to_s
    cdst = expand_path(cf['destination'], prefix)
    mode = cf['mode'] || '0600'

    puts "\n--- Config file ---"
    unless File.exist?(csrc)
      msg = "Source not found: #{csrc}"
      dry_run ? warn_("Would skip: #{msg}") : warn_(msg)
      next
    end

    if File.exist?(cdst) && cf['skip_if_exists'] && !opts[:force]
      msg = "Exists, would skip: #{cdst}  (--force to overwrite)"
      dry_run ? dry(msg) : info(msg)
      next
    end

    info "Would copy: #{csrc} → #{cdst}  (mode #{mode})" if dry_run
    fs_cp(csrc, cdst, mode, opts)
    ok "#{csrc} → #{cdst}  (mode #{mode})" unless dry_run
  end

  # Post-install notes (always shown — they're manual steps regardless)
  notes = Array(manifest['post_install_notes'])
  unless notes.empty?
    puts "\n--- Post-install manual steps ---"
    notes.each { |n| warn_ n }
  end

  suffix = dry_run ? ansi('36', '✔  Dry-run complete. Nothing was written.')                    : ansi('32', '✔  Installation complete.')
  puts "\n#{suffix}"
end

# ---------------------------------------------------------------------------
# --uninstall  (also handles --uninstall --dry-run)
# ---------------------------------------------------------------------------

def do_uninstall(manifest, opts)
  prefix  = opts[:prefix]
  dry_run = opts[:dry_run]

  banner = dry_run ? "DRY-RUN — no files will be removed" : "Uninstalling #{manifest['name']}"
  puts "\n=== #{banner} ===\n"

  # Binary
  bin     = manifest['binary'] || {}
  dst_dir = expand_path(bin['destination'] || "#{prefix}/bin", prefix)
  dst     = File.join(dst_dir, bin['target'] || File.basename(bin['source'].to_s, '.*'))

  puts "--- Binary ---"
  if File.exist?(dst)
    info "Would remove: #{dst}" if dry_run
    fs_rm(dst, opts)
    ok "Removed #{dst}" unless dry_run
  else
    warn_ "Not found (already removed?): #{dst}"
  end

  # Man pages
  Array(manifest['man_pages']).each do |mp|
    mdir = expand_path(mp['destination'] || "#{prefix}/share/man/man#{mp['section']}", prefix)
    mdst = File.join(mdir, File.basename(mp['source'].to_s))

    puts "\n--- Man page ---"
    if File.exist?(mdst)
      info "Would remove: #{mdst}" if dry_run
      fs_rm(mdst, opts)
      ok "Removed #{mdst}" unless dry_run
    else
      warn_ "Not found: #{mdst}"
    end
  end

  # Config files — only removed if explicitly listed (never auto-remove dirs)
  Array(manifest['config_files']).each do |cf|
    cdst = expand_path(cf['destination'], prefix)
    next unless File.exist?(cdst)
    puts "\n--- Config file ---"
    warn_ "config file: #{cdst}"
    warn_ "  Not auto-removing config — delete manually if desired"
    dry "  Would NOT remove: #{cdst}  (config files are never auto-deleted)" if dry_run
  end

  notes = Array(manifest['uninstall_notes'])
  unless notes.empty?
    puts "\n--- Manual cleanup ---"
    notes.each { |n| warn_ n }
  end

  suffix = dry_run ? ansi('36', '✔  Dry-run complete. Nothing was removed.')                    : ansi('32', '✔  Uninstall complete.')
  puts "\n#{suffix}"
end

# ---------------------------------------------------------------------------
# --check  (dependency check only — no file operations, no dry-run needed)
# ---------------------------------------------------------------------------

def do_check(manifest, opts)
  prefix = opts[:prefix]
  name   = manifest['name'] || '(unknown)'
  ver    = manifest['version'] || '?'

  puts "=== Dependency check: #{name} v#{ver} ===\n"
  issues = check_deps(manifest)

  puts "\n=== Install plan (prefix: #{prefix}) ==="
  bin     = manifest['binary'] || {}
  dst_dir = expand_path(bin['destination'] || "#{prefix}/bin", prefix)
  info "Binary:   #{bin['source']} → #{dst_dir}/#{bin['target']}"

  Array(manifest['man_pages']).each do |mp|
    mdir = expand_path(mp['destination'] || "#{prefix}/share/man/man#{mp['section']}", prefix)
    info "Man(#{mp['section']}): #{mp['source']} → #{mdir}/"
  end

  Array(manifest['config_dirs']).each  { |cd| info "Config dir:  #{expand_path(cd['path'], prefix)}" }
  Array(manifest['config_files']).each { |cf| info "Config file: #{cf['source']} → #{expand_path(cf['destination'], prefix)}" }

  puts ''
  if issues.empty?
    puts ansi('32', '✔  All checks passed. Ready to install.')
    puts "    Run with --install to proceed, --install --dry-run to preview."
  else
    puts ansi('33', "⚠  #{issues.size} issue(s) — see above.")
    exit 1
  end
end

# ---------------------------------------------------------------------------
# Dispatch
# ---------------------------------------------------------------------------

case options[:action]
when :install   then do_install(MANIFEST, options)
when :uninstall then do_uninstall(MANIFEST, options)
when :check     then do_check(MANIFEST, options)
end
