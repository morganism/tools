# colour and cursor movement
ansi() {
  [[ -f ~/.ansi.functions ]] && source ~/.ansi.functions
}
deprecated() {
  ansi
  echo -en "${Red}${On_Yellow}Deprecated${Reset} "
  __SEE=$1

  if [[ -n "${__SEE}" ]]; then
    if [[ "$(type -t ${__SEE})" =~ function ]]; then
      read __FNAME __FLINE __FFILE < <((shopt -s extdebug; declare -F ${__SEE})) 
      echo -en " ${Blue}SEE${Black}: ${uCyan}${__FNAME}()${Reset} ${Blue}defined in${Reset} ${Purple}${__FFILE}${dWhite}(${White}${__FLINE}${dWhite})${Reset}."
    fi
  fi
  echo -e "."
}
export MY_FUNCTIONS_SOURCE_DATE=$(date)
check_source_date() {
  ansi
  echo -e "${White}0: ${uWhite}$MY_FUNCTIONS_SOURCE_DATE"
  echo ""
  echo -e "${White}1: ${uWhite}$(date)${Reset}"
}
THIS_PATH() {
  # return absolute path to the script where THIS_PATH is called from
    realpath "${BASH_SOURCE[1]}"
}
THIS_DIR() {
    dirname "$(realpath "${BASH_SOURCE[1]}")"
}
THIS_FILE() {
    basename "$(realpath "${BASH_SOURCE[1]}")"
}
set_pgservice() { 
    if [[ -z "$1" ]]; then
        echo $0
        exit 1
    fi 
    if [[ "$1" == "localdb" ]]; then
        echo "localdb"
        export PGSERVICE="localdb"
    elif [[ "$1" == "aws_dev" ]]; then
        echo "aws_dev"
        export PGSERVICE="aws_dev"
    fi
    echo "PGSERVICE=$PGSERVICE"
}
THIS="$(realpath $BASH_SOURCE)"
DIR="$(dirname $THIS)"

LIB_COLOURS="~/.ansi.functions"
[[ -f "${DIR}/${LIB_COLOURS}" ]] && source "${DIR}/${LIB_COLOURS}"

# --------------------
colours() {
  # Colors for output
  RED='\033[0;31m'
  GREEN='\033[0;32m'
  YELLOW='\033[1;33m'
  BLUE='\033[1;34m'
  NC='\033[0m' # No Color
}
mcd() {           # create and cd
    [[ -e "$1" ]] && [[ ! -d "$1" ]] && echo "Error: $1 is not a directory" && return 1
    [[ ! -e "$1" ]] && mkdir -p "$1"
    [[ -d "$1" ]] && pushd "$1"
}
progress() {
  local msg="$1"
  local total="${2:-100}"
  local delay="${3:-0.05}"

  echo -n "$msg "
  for ((i=0; i<=total; i++)); do
    printf "\r%s %3d%%" "$msg" "$i"
    sleep "$delay"
  done
  echo -e "\r$msg 100% ✓"
}

vi_my_aliases() {
  #-----------
  #--- vma ---
  #-----------
  vi ~/.my_aliases
  source ~/.my_aliases
}
vi_my_functions() {
  #-----------
  #--- vmf ---
  #-----------
  echo -e "${Red}${On_White}Function:${Reset} ${IBlue}${BASH_SOURCE}[vi_my_functions()]${Reset}"
  vi ~/.my_functions
  source ~/.my_functions
}
config_init() {
  #-----------
  # setup the .config dir structure if not present
  #-----------
  CALL_DIR=$(pwd)
  
  # Colors for output
  RED='\033[0;31m'
  GREEN='\033[0;32m'
  YELLOW='\033[1;33m'
  BLUE='\033[1;34m'
  NC='\033[0m' # No Color

  echo -e "${BLUE}Checking for ${YELLOW}.config${BLUE} directory in ${YELLOW}${CALL_DIR}${BLUE} ... ${NC}"

  if [[ -d "${CALL_DIR}/.config" ]]; then
    echo -e "${YELLOW}.config${GREEN} directory exists.${NC}"
  else
    echo -e "${RED}Missing ${YELLOW}.config ${BLUE} directory structure, creating ... ${NC}"
    CONFIG_DIR="${CALL_DIR}/.config"
    mkdir -p "${CONFIG_DIR}"
    cd "$CONFIG_DIR"
    BSF="${CONFIG_DIR}/bootstrap"
    for f in $(echo "env functions aliases")
    do
      touch $f
      RP=$(realpath $f)
      echo "source $RP" >> "$BSF"
      echo -en "${GREEN} . ${NC}"
    done
    $(chmod 755 "$BSF")
    echo -en "${GREEN} . ${NC}"
  fi
  echo -e "${GREEN}Finished!${NC}"
}
__guess() {
  echo $1
  
}
#cd() {
  #builtin cd "$1" &>/dev/null
  #if [[ "$?" = "0" ]]; then
    #P0=$(realpath "$1")    # actual dest
    #P1="$1"                # typed dest
    #P2=$PWD                # start dir
    #HIST="/tmp/zd.history"
    #H_P0="/tmp/zd.h_p0"
    #echo "$P0:$P1:$P2" >> $HIST
    #cat $HIST | awk -F: '{print $1}' | sort | uniq -c | sort -rn > $H_P0 
  #else
    #echo -e "${IGreen}O${Yellow}p${Cyan}p${Blue}o${Purple}r${BIBlack}t${White}u${Green}n${Red}i${Blue}t${IWhite}y${NC} to guess"
    ##__guess $1
  #fi
#}
open22() {
  if [[ -z "$OPENSSH" ]]; then
    OPENSSH=$(nmap -p22 10.71.157.* --open | grep report | sed -e 's/^.*report for //' -e 's:.* (::' -e 's:)::')
  fi

  echo $OPENSSH
}
linktools() {
  TOOLSDIR="${HOME}/src/morganism/tools"
  if [[ -d $TOOLSDIR ]]; then
    cd $TOOLSDIR
    LINKER_N
    LINKER_CMD="linker"
    if [[ -x "${TOOLSDIR}/${LINKER_CMD}" ]]; then
      echo "Linking tools/bin to ~/bin and tools/dotfiles to ~ ..."
      ./$LINKER_CMD
      echo "Linking exited with: $?"
    else
      echo "Hmmm .. Linker command ${LINKER_CMD} does not exist here: ${TOOLSDIR}/${LINKER_CMD}."
      exit 2
    fi
  else
    echo "Git repo 'tools' [git@github.com:morganism/tools.git] is not checked out in the expected location: ${TOOLSDIR}"
    exit 1
  fi
}

rp2pb() {
  # realpath 2 paste board get the realpath of the file or directory specified as an arg: rp2pb FILE

  realpath $1 | pbcopy
  echo "realpath of $1 is in pasteboard $(pbpaste)"
}

savealias() {
  source ~/.my_aliases
  THE_ALIAS=$(alias $1)
  if [[ -z "${THE_ALIAS}" ]]; then
    echo "Alias $1 not defined. [${THE_ALIAS}][$(${THE_ALIAS})]"
    return 1
  else
    echo "Alias $1 defined. [${THE_ALIAS}][$(${THE_ALIAS})]"
    echo "${THE_ALIAS}" >> ~/.my_aliases
    source ~/.my_aliases
  fi
}
colours() {
  [[ -f ~/.ansi.functions ]] && source ~/.ansi.functions && echo -en "${fGreen}OK${Reset}" || echo -en "${\033[31m}ERROR loading ~/.ansi.functions${Reset}"
  sleep 0.8
  echo -en "$(cursor_left 2)${clear_to_eol}$(cursor_left 2)${clear_to_eol}"
}
fade() {
  source ~/.ansi.functions
  R=$1
  G=$2
  B=$3
  M=$4
  
  echo -en "\033[38;2;${R};${G};${B}m${M}${Reset}"
}
claude_github_wf() {
  REPO="$1"
  DIR=".github/workflows/claude.yml"
}
#check and recover from the vi emacs keymap shite
bindv() {
  ansi
  bind -v | tail -7 | sed -e 's:\([@+:]\):\1      «««:'
  NEED_RESET="$(bind -v | grep -c [@:+])"
  if [[ "$NEED_RESET" = "0" ]]; then
    echo -e "${Green}All's well here${Reset}"
  else
    echo -e "${Reset}${Yellow}Maybe we should run: ${iYellow}${uUnderline}bindreset${Reset}"
  fi
}
  
bindreset() {
  ansi
  echo -e "${Reset}${Yellow}Good idea to run me${Reset}"
  echo -e "${IBlack}bind '${White}set ${bIWhite}emacs-mode-string${White} \"\"${rRegular}'${Reset}"
  bind 'set emacs-mode-string ""'
  echo -e "${IBlack}bind '${White}set ${bIWhite}vi-ins-mode-string${White} \"\"${rRegular}'${Reset}"
  bind 'set vi-ins-mode-string ""'
  echo -e "${IBlack}bind '${White}set ${bIWhite}vi-cmd-mode-string${White} \"\"${rRegular}'${Reset}"
  bind 'set vi-cmd-mode-string ""'
  echo -e "${Reset}${Green}all good now${Reset}"
}


#GIT_BRANCH=$(git branch -l | grep ^\* | sed -e 's:^\* ::')
#git push --set-upstream origin SCALPEL_ORTUS
#fatal: The current branch SCALPEL_ORTUS has no upstream branch.
#To push the current branch and set the remote as upstream, use
#
#   git push --set-upstream origin SCALPEL_ORTUS
#
# wrap 'git push' to set upstream if necessary
git() {
  GIT_CMD="/usr/local/git/bin/git"
  GIT_BRANCH=$($GIT_CMD branch -l | grep ^\* | sed -e 's:^\* ::')
  if [[ $1 = "push" ]]; then
    ansi
    echo -e "${Blue}${On_White}wrap 'git push'${Reset}"
    if  [[ $($GIT_CMD push 2>&1| grep 'has no upstream') ]]; then
      echo $GIT_CMD push --set-upstream origin $GIT_BRANCH 
      sleep 10
      $GIT_CMD push --set-upstream origin $GIT_BRANCH 
    fi
  elif [[ $1 = "add" ]]; then
    ansi
    echo -e "${Green}Current branch is:${Reset} ${White}$GIT_BRANCH${Reset}"
    if [[ "$GIT_BRANCH" =~ master ]]; then
      echo "master"
    else
      echo "not"
    fi
  else
    $GIT_CMD "$@"
  fi
}
kv() {
  secret=$1

  # Extract the KEY and VALUE
  KEY="${secret%%:*}"
  VALUE="${secret##*:}"

  # Print the results
  echo "Key: $KEY"
  echo "Value: $VALUE"
}
newrepo() {
  ansi

  usage() {
    echo -e "${Blue}usage: ${IBlack}newrepo ${IBlack}<repo-name> [${IWhite}public|${White}private${IBlack}]${Reset}"
    return 1
  }
  git_init_error() {
    echo -e "${Red}Error calling: git init${Reset}"
  }
  git_commit_error() {
    echo -e "${Red}Error calling: git commit${Reset}"
  }

  local REPO_NAME="$1"
  local VISIBILITY="${2:-public}"

  git init || git_init_error
  git add .
  git commit -m "initial commit" || git_commit_error

  gh repo create "$REPO_NAME" \
    --"$VISIBILITY" \
    --source="." \
    --remote="origin" \
    --push
}
claude() {
    # Pre-cleanup
    printf '\e[?2004l\e[0m'
    stty sane
    
    command claude "$@"
    local exit_code=$?
    
    # Post-cleanup
    printf '\e[?2004l\e[0m'
    stty sane
    
    return $exit_code
}
genpasswd() {
  ansi
  [[ "${1}${2}" =~ -h ]] && echo -e "${dCyan}Usage: ${Cyan}genpasswd${Reset} ${IWhite}[-h]${Reset} ${IYellow}LENGTH${Reset}" && return 1
  LEN=${1:-12}
  ALPHANUM='A-Za-z0-9'
  SYMBOLS='!@£$%^0-9'
  PASSCHARS=$ALPHANUM
  if [[ -z "${2:-$USE_SYMBOLS}" ]] || [[ "$USE_SYMBOLS" =~ [Yy] ]]; then
    PASSCHARS+=$SYMBOLS
  fi
  export LC_ALL=C 
  tr -dc $PASSCHARS < /dev/random | head -c $LEN | xargs
}
port() {
  PORT=${1-1}
  lsof -i :$PORT
}

command_not_found_handle () {
  ansi
  echo -e "${IRed}${On_White} ${BASH_SOURCE}[command_not_found_handle()]#[${BASH_LINENO}] invoked${Reset}"
  #find / -type d -name '*bin*' -o -name '.*/bin'
}
where_am_i () {
  ansi
  echo -e "${IRed}${On_White} ${BASH_SOURCE}[where_am_i()]#[${BASH_LINENO[-2]}] invoked${Reset}"
}

github-create() {
 repo_name=$1

 dir_name=`basename $(pwd)`

 if [ "$repo_name" = "" ]; then
 echo "Repo name (hit enter to use '$dir_name')?"
 read repo_name
 fi

 if [ "$repo_name" = "" ]; then
 repo_name=$dir_name
 fi

 username=`git config github.user`
 if [ "$username" = "" ]; then
 echo "Could not find username, run 'git config --global github.user <username>'"
 invalid_credentials=1
 fi

 token=`git config github.token || $(echo $GITHUB_TOKEN)`
 if [ "$token" = "" ]; then
 echo "Could not find token, run 'git config --global github.token <token>'"
 invalid_credentials=1
 fi

 if [ "$invalid_credentials" == "1" ]; then
 return 1
 fi

 echo -n "Creating Github repository '$repo_name' ..."
 curl -u "$username:$token" https://api.github.com/user/repos -d '{"name":"'$repo_name'"}' > /dev/null 2>&1
 echo " done."

 echo -n "Pushing local code to remote ..."
 git remote add origin git@github.com:$username/$repo_name.git > /dev/null 2>&1
 git push -u origin master > /dev/null 2>&1
 echo " done."
}

function_definition() { 
  deprecated fndef
  fndef $1
}
